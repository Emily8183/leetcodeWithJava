LC112  路径总和
.
步骤：
递归法，把目标值直接作为参数传入，通过遍历只要清零，就是找到路径return true，相反return false。(注意这题需要return)
.
终止条件：
1）当遇到叶子节点并且目标值变为零（即node.left ==null && node.right == null && targetsum ==0)，就是遍历到了叶子节点且找到了目标值，return true。
2）相反，遇到叶子节点而没有找到合适的路径，return false。

LC113 路径总和II
.
步骤:
1）还是通过深度优先遍历（DFS）来实现。定义两个成员变量：result用于存储所有满足条件的路径，path用于存储当前搜索路径。
2）用pathSum函数作为对外的接口函数，初始化result和path，然后调用traversal函数来做深度优先遍历。
3）traversal函数：递归遍历二叉树左右子树的每个节点。
在每个节点处，将节点值加入path，并将目标值减去节点值。
.
和112一样，如果当前节点是叶子节点且目标值为0，说明找到了一条满足条件的路径。在113里，需要将path加入result。
.
4）添加回溯，将当前节点从path中移除，不然都会堆砌在一起。
.
Tips:
1）这题遍历整棵树后，需要找出所有路径，所以这里的递归函数不需要返回值；
2）递归本身就有回溯的特性。
.
在这一题，需要特地撤销当前节点对路径的影响，这样可以正确处理其他路径，不至于把节点都堆砌在一起。
.
针对LC给出的例子，[[5,4,11,2],[5,8,4,5]]。
.
访问到叶子节点（7和2）时，需要返回到它们的父节点（11），并移除叶子节点（7和2）对路径的影响。
.
区别在于[5,4,11,2]的总和等于targetNum，在移除2前会将此条路径保留至result。